[
  {
    "id" : "007b1a90-d68d-40ed-b6a9-806736013fe9",
    "prId" : 102848,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/102848#pullrequestreview-686625539",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "85571939-f2d1-4dca-b544-8499fe995d6b",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "I claim this test is incorrect - in connection to the comment that I added in the main code.",
        "createdAt" : "2021-06-16T15:44:25Z",
        "updatedAt" : "2021-06-16T15:44:25Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "d17b7899-3f99-42d9-8697-d526cd3c8ef3",
        "parentId" : "85571939-f2d1-4dca-b544-8499fe995d6b",
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "this test does not exercise the entire enqueu, select, dequeue and finish path, it just ensures that the given a snapshot of a `queueSet`, `selectQueueLocked` returns the queue with the minimum virtual finish time and also there are enough seats available\r\n",
        "createdAt" : "2021-06-17T17:45:39Z",
        "updatedAt" : "2021-06-17T17:45:39Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      }
    ],
    "commit" : "ff716cef508f948b50e1026e980e6df5ee475538",
    "line" : 128,
    "diffHunk" : "@@ -1,1 +914,918 @@\t\t\t},\n\t\t\tattempts:              3,\n\t\t\tminQueueIndexExpected: []int{-1, -1, 1},\n\t\t\trobinIndexExpected:    []int{1, 1, 1},\n\t\t},"
  },
  {
    "id" : "e5e1ed6d-75f4-4203-b523-8d544043045b",
    "prId" : 91761,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91761#pullrequestreview-426223403",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "b9c58d41-eee2-4b07-ac30-a10ab2384cee",
        "parentId" : null,
        "authorId" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "body" : "can you elaborate the point of `time.Second - 1` (1 sec - 1 nano-sec)? what's the difference from exactly 1 sec?",
        "createdAt" : "2020-06-08T07:48:20Z",
        "updatedAt" : "2020-07-14T14:05:31Z",
        "lastEditedBy" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "tags" : [
        ]
      },
      {
        "id" : "f3ddc868-54bc-4da1-b6dd-4cfa86d8414e",
        "parentId" : "b9c58d41-eee2-4b07-ac30-a10ab2384cee",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "This sort of configuration gets into a cadence where every 1000000000 nanoseconds some requests finish, and 1 ns before that some more arrive.  That means that when one request finishes, the dispatcher already has all the requests it will consider.  If the arrivals were at the same fake time as the completions then we are at the mercy of the golang goroutine scheduler: some dispatching may happen before some of the request arrivals.",
        "createdAt" : "2020-06-08T13:17:45Z",
        "updatedAt" : "2020-07-14T14:05:31Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3fdd5cf9f51f2a03ebfddef82bc2014e04b62a0",
    "line" : 479,
    "diffHunk" : "@@ -1,1 +403,407 @@\t\tqs: qs,\n\t\tclients: []uniformClient{\n\t\t\t{1001001001, 8, 20, time.Second, time.Second - 1, false},\n\t\t\t{2002002002, 8, 20, time.Second, time.Second - 1, false},\n\t\t},"
  },
  {
    "id" : "ab2125a0-ae95-4c1e-b61d-1257a0a40709",
    "prId" : 91761,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91761#pullrequestreview-426225108",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "47e4a18f-f644-4e53-ac00-54a42dc949c7",
        "parentId" : null,
        "authorId" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "body" : "`[]bool expectFair` is indeed less confusing than `expectFair[1|2]`, while for now  how about we commenting something like: \r\n\r\n`expectFair` is an array of single element indicating whether the concurrency distribution is overall fair for non-split cases. and the on the other hand for split cases, it's a two-element array with `expectFair[0]` indicating whether the splitted half is fair and `expectFair[1]` indicating the overall distribution is fair..",
        "createdAt" : "2020-06-08T08:02:03Z",
        "updatedAt" : "2020-07-14T14:05:31Z",
        "lastEditedBy" : "bc182326-9017-48d6-8ee0-4609046c1366",
        "tags" : [
        ]
      },
      {
        "id" : "ddef4c52-0007-479f-b7c9-12c90217ac20",
        "parentId" : "47e4a18f-f644-4e53-ac00-54a42dc949c7",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "I think it is more meaningful to evaluate the two halves rather than the whole.  The whole will show a lesser degree of whatever effects there may be than an individual half.",
        "createdAt" : "2020-06-08T13:19:52Z",
        "updatedAt" : "2020-07-14T14:05:31Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3fdd5cf9f51f2a03ebfddef82bc2014e04b62a0",
    "line" : 117,
    "diffHunk" : "@@ -1,1 +125,129 @@\tconcurrencyLimit                         int\n\tevalDuration                             time.Duration\n\texpectFair                               []bool\n\texpectAllRequests                        bool\n\tevalInqueueMetrics, evalExecutingMetrics bool"
  },
  {
    "id" : "2f4ef57a-b78d-4468-8fe8-b9f037577050",
    "prId" : 91761,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/91761#pullrequestreview-446026634",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c7090da5-ae4b-4e33-b5f5-629706ef8156",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "This is less deeply nested, so I'm going to assume it's a large improvement :)",
        "createdAt" : "2020-07-09T23:41:31Z",
        "updatedAt" : "2020-07-14T14:05:31Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      }
    ],
    "commit" : "f3fdd5cf9f51f2a03ebfddef82bc2014e04b62a0",
    "line" : 204,
    "diffHunk" : "@@ -1,1 +169,173 @@\t\tuss.expectedInqueue = uss.expectedInqueue + fmt.Sprintf(`\t\t\t\tapiserver_flowcontrol_current_inqueue_requests{flowSchema=%q,priorityLevel=%q} 0%s`, fsName, uss.name, \"\\n\")\n\t\tfor j := 0; j < uc.nThreads; j++ {\n\t\t\tust := uniformScenarioThread{\n\t\t\t\tuss:    uss,\n\t\t\t\ti:      i,"
  },
  {
    "id" : "c9eb1846-a204-4120-a937-a09dfd56ea3e",
    "prId" : 88714,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/88714#pullrequestreview-369831871",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "e2a2157f-e16a-42ed-9257-89d10a41ddba",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "Is this really how people normally test metrics? I really would have expected to read the desired values and compare ints/floats. I'd also be satisfied with just reading the gauge directly if that's possible. @logicalhan ",
        "createdAt" : "2020-03-05T18:11:15Z",
        "updatedAt" : "2020-03-05T20:18:05Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "f156f7aa-ebe0-4343-b700-57217b7b93d5",
        "parentId" : "e2a2157f-e16a-42ed-9257-89d10a41ddba",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "I found this pattern when looking at other metrics_test.go files in k8s.io/apiserver.",
        "createdAt" : "2020-03-05T19:00:05Z",
        "updatedAt" : "2020-03-05T20:18:05Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "c7b098ac6c276d65a79db6cfeb04f5f0f86eb315",
    "line" : 189,
    "diffHunk" : "@@ -1,1 +291,295 @@\t\t{2002002002, 4, 15, time.Second, 750 * time.Millisecond},\n\t}, time.Second*13, false, false, false, true, \"concurrency-limit\", clk, counter)\n\terr = metrics.GatherAndCompare(`\n\t\t\t\t# HELP apiserver_flowcontrol_rejected_requests_total [ALPHA] Number of requests rejected by API Priority and Fairness system\n\t\t\t\t# TYPE apiserver_flowcontrol_rejected_requests_total counter"
  },
  {
    "id" : "80b36fae-8803-468b-8978-0b645fbe3f52",
    "prId" : 88714,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/88714#pullrequestreview-369881901",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "ecd2cd71-e533-4f1a-8f5d-bedb8d4af82b",
        "parentId" : null,
        "authorId" : "b86e7e78-bb07-417f-8470-39407559c779",
        "body" : "From my reading of the code, timed out requests could get deducted from the wrong FS; I think a test should detect that if it happens (for any reason), but it's not clear that this one does?\r\n\r\nE.g. after everything is done, the metrics should show zero executing requests, or the sum of rejected+processed needs to match what was sent, something like that?",
        "createdAt" : "2020-03-05T18:13:51Z",
        "updatedAt" : "2020-03-05T20:18:05Z",
        "lastEditedBy" : "b86e7e78-bb07-417f-8470-39407559c779",
        "tags" : [
        ]
      },
      {
        "id" : "2b96e28f-c3d8-4442-bc18-59ba53bb6a7d",
        "parentId" : "ecd2cd71-e533-4f1a-8f5d-bedb8d4af82b",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "Yes, timeouts should be tested and this function does not do that.",
        "createdAt" : "2020-03-05T18:58:23Z",
        "updatedAt" : "2020-03-05T20:18:05Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "a292fdf6-b14c-4cfe-9c59-fb4ed17b794a",
        "parentId" : "ecd2cd71-e533-4f1a-8f5d-bedb8d4af82b",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "I have added some examination of metrics for rejection.",
        "createdAt" : "2020-03-05T20:15:12Z",
        "updatedAt" : "2020-03-05T20:18:05Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "c7b098ac6c276d65a79db6cfeb04f5f0f86eb315",
    "line" : 40,
    "diffHunk" : "@@ -1,1 +74,78 @@\t\tintegrators[i] = test.NewIntegrator(clk)\n\t\tfsName := fmt.Sprintf(\"client%d\", i)\n\t\texpectedInqueue = expectedInqueue + fmt.Sprintf(`\t\t\t\tapiserver_flowcontrol_current_inqueue_requests{flowSchema=%q,priorityLevel=%q} 0%s`, fsName, name, \"\\n\")\n\t\tfor j := 0; j < uc.nThreads; j++ {\n\t\t\tcounter.Add(1)"
  },
  {
    "id" : "1f52de21-87fb-4c10-9d50-0f0d23c58334",
    "prId" : 103240,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103240#pullrequestreview-728222674",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "c96534c9-002e-4406-8bfc-262b439a6a42",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "And following on @MikeSpreitzer comment, you can also check time now - it should be now+additional_latency at this point",
        "createdAt" : "2021-08-12T06:34:08Z",
        "updatedAt" : "2021-08-12T06:34:32Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "d68186452d9150b113489e6a722caf82f898857f",
    "line" : 60,
    "diffHunk" : "@@ -1,1 +1050,1054 @@\t\t\t// as soon as AdditionalLatency elapses we expect the seats to be released\n\t\t\tclk.SetTime(now.Add(test.workEstimate.AdditionalLatency))\n\n\t\t\tif queuesetTotalRequestsExecutingExpected != qs.totRequestsExecuting {\n\t\t\t\tt.Errorf(\"Expected total requests executing: %d, but got: %d\", queuesetTotalRequestsExecutingExpected, qs.totRequestsExecuting)"
  },
  {
    "id" : "4c4f2ca0-cdd8-4843-a9e8-9cf8d23db513",
    "prId" : 103240,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103240#pullrequestreview-728815299",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "38483bd0-3d57-46a8-a9af-0f4bcd2c515b",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Why not run clk.Run(nil)\r\n\r\n[but then Mike`s comment about proper initialization of QS is a valid one]",
        "createdAt" : "2021-08-12T14:12:26Z",
        "updatedAt" : "2021-08-12T14:16:05Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "d0f79ac9-6f52-4c00-9998-a6ca363526d2",
        "parentId" : "38483bd0-3d57-46a8-a9af-0f4bcd2c515b",
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "> Why not run clk.Run(nil)\r\n\r\n@wojtek-t for the test at hand, `clk.SetTime` is more concise in expressing the expectation that the event function should be executed immediately after `AdditionalLatency` elapses. So this is a verification step.\r\n\r\nAlternatively, we can achieve this with `clk.Run(nil)` too:\r\n```\r\nclk.Run(nil)\r\nget the time when the event fired and assert that it happened after AdditionalLatency elapsed\r\n```\r\n\r\nI think `SetTime` does the job concisely, thoughts?",
        "createdAt" : "2021-08-12T14:54:57Z",
        "updatedAt" : "2021-08-12T14:54:58Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      },
      {
        "id" : "7e677fcc-1e42-4a42-867d-73122c208729",
        "parentId" : "38483bd0-3d57-46a8-a9af-0f4bcd2c515b",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "In my opinion, using `SetTime` to the precise time needed is sufficient for a test of `finishRequestLocked`.  Using `clk.Run(nil)` would also be OK, and adding a test that `Run` advanced the fake time to the exact correct value would be better.",
        "createdAt" : "2021-08-12T16:08:36Z",
        "updatedAt" : "2021-08-12T16:08:36Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "d68186452d9150b113489e6a722caf82f898857f",
    "line" : 59,
    "diffHunk" : "@@ -1,1 +1049,1053 @@\n\t\t\t// as soon as AdditionalLatency elapses we expect the seats to be released\n\t\t\tclk.SetTime(now.Add(test.workEstimate.AdditionalLatency))\n\n\t\t\tif queuesetTotalRequestsExecutingExpected != qs.totRequestsExecuting {"
  },
  {
    "id" : "a3b19388-1bd7-4665-ae86-564475f95ca8",
    "prId" : 103240,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/103240#pullrequestreview-729621092",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "4d2d9715-c029-4363-af3d-0ed92d9e6e6e",
        "parentId" : null,
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "If we really want to lock down the behavior of `finishRequestLocked`, we could also check the values one nanosecond before the proper release time.",
        "createdAt" : "2021-08-13T01:50:30Z",
        "updatedAt" : "2021-08-13T01:50:30Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "a19332de-4194-431b-96b2-a4ab12edb79a",
        "parentId" : "4d2d9715-c029-4363-af3d-0ed92d9e6e6e",
        "authorId" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "body" : "Yes, I will update the test to assert on this. ",
        "createdAt" : "2021-08-13T13:32:52Z",
        "updatedAt" : "2021-08-13T13:32:53Z",
        "lastEditedBy" : "3e6e337f-0beb-4609-abc3-11b8e8cf5688",
        "tags" : [
        ]
      }
    ],
    "commit" : "d68186452d9150b113489e6a722caf82f898857f",
    "line" : 58,
    "diffHunk" : "@@ -1,1 +1048,1052 @@\t\t\tqs.finishRequestLocked(r)\n\n\t\t\t// as soon as AdditionalLatency elapses we expect the seats to be released\n\t\t\tclk.SetTime(now.Add(test.workEstimate.AdditionalLatency))\n"
  },
  {
    "id" : "d544da3c-8b08-408c-a543-bd885052c002",
    "prId" : 104002,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/104002#pullrequestreview-724733961",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "1fdce08c-1524-4978-95cb-944675bf1600",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "IIUC, you need to lock here to avoid concurrent t.Errorf() calls.\r\n\r\nGiven you need it, let's remove the expecteQNCounts() function above and use just this one.",
        "createdAt" : "2021-08-06T07:42:40Z",
        "updatedAt" : "2021-08-06T07:50:35Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "493bc7a9-bec2-48b3-9d75-cb2f70ea5492",
        "parentId" : "1fdce08c-1524-4978-95cb-944675bf1600",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "done",
        "createdAt" : "2021-08-06T21:58:02Z",
        "updatedAt" : "2021-08-06T21:58:03Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      }
    ],
    "commit" : "1db36ae3b30e30d70972998a22987a7db470479b",
    "line" : 165,
    "diffHunk" : "@@ -1,1 +692,696 @@\t\t\terrsLock.Lock()\n\t\t\tdefer errsLock.Unlock()\n\t\t\tfatalErrs = append(fatalErrs, fmt.Sprintf(\"Got %d calls to queueNoteFn%d(%v), expected %d\", a, fn, inQueue, expect))\n\t\t}\n\t}"
  },
  {
    "id" : "3699b66f-c6fd-4d8c-acb8-60d3021749c8",
    "prId" : 104002,
    "prUrl" : "https://github.com/kubernetes/kubernetes/pull/104002#pullrequestreview-726045426",
    "prSource" : "GitHub",
    "comments" : [
      {
        "id" : "cd0181dd-572b-477e-8f84-0da972a021ce",
        "parentId" : null,
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "let's remove idle1 from here and define it as it was",
        "createdAt" : "2021-08-09T07:42:03Z",
        "updatedAt" : "2021-08-09T08:07:22Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      },
      {
        "id" : "b8caa811-3cb7-4a26-87e7-ce49df6d241f",
        "parentId" : "cd0181dd-572b-477e-8f84-0da972a021ce",
        "authorId" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "body" : "I think I need to define the variable up front, it is set in a forked goroutine and checked in the main goroutine.  The request processing needs to be in a forked goroutine so that it can run concurrently with the doneCh reaction under management of the fake clock.",
        "createdAt" : "2021-08-09T22:11:21Z",
        "updatedAt" : "2021-08-09T22:11:21Z",
        "lastEditedBy" : "7a59a326-58b3-4590-b70a-297d2e27daa5",
        "tags" : [
        ]
      },
      {
        "id" : "ed082541-3e77-4d99-b016-8853d1f59e51",
        "parentId" : "cd0181dd-572b-477e-8f84-0da972a021ce",
        "authorId" : "24302707-9254-48df-89a5-cbcc349462b8",
        "body" : "Sorry - I missed that it's being exercised at the end of the test.",
        "createdAt" : "2021-08-10T06:29:12Z",
        "updatedAt" : "2021-08-10T06:32:53Z",
        "lastEditedBy" : "24302707-9254-48df-89a5-cbcc349462b8",
        "tags" : [
        ]
      }
    ],
    "commit" : "1db36ae3b30e30d70972998a22987a7db470479b",
    "line" : 196,
    "diffHunk" : "@@ -1,1 +705,709 @@\t}\n\texpectQNCounts(1, 1, 1)\n\tvar executed1, idle1 bool\n\tcounter.Add(1) // account for the following goroutine\n\tgo func() {"
  }
]